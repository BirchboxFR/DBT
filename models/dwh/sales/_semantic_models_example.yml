# EXEMPLE ÉDUCATIF - Montre comment les entités permettent les jointures
# Ce fichier n'est PAS actif, juste pour documentation

semantic_models:
  # ========================================
  # 1. Box Sales (ce qu'on a créé)
  # ========================================
  - name: box_sales_semantic
    model: ref('box_sales')
    entities:
      - name: sub_id
        type: primary      # ✅ Vraie clé unique : sub_id (car un user peut avoir 2 box)
        expr: sub_id

      - name: user_key
        type: foreign      # ✅ MEILLEURE jointure avec customers (pays_user_id)
        expr: user_key

      - name: user_id
        type: foreign      # ⚠️ Seul insuffisant, combiner avec dw_country_code
        expr: user_id

      - name: box_id
        type: foreign      # Permet de joindre avec boxes_semantic
        expr: box_id

      - name: order_id
        type: foreign      # Permet de joindre avec orders_semantic
        expr: order_id

    measures:
      - name: total_revenue
        agg: sum
        expr: net_revenue

  # ========================================
  # 2. Customers (exemple hypothétique)
  # ========================================
  - name: customers_semantic
    model: ref('customers')
    entities:
      - name: user_key
        type: primary      # ✅ Clé primaire avec pays (ex: FR_12345)
        expr: CONCAT(dw_country_code, '_', CAST(user_id AS STRING))

      - name: user_id
        type: foreign      # ID numérique seul (attention multi-pays)
        expr: user_id

    dimensions:
      - name: customer_age_group
        type: categorical
        expr: age_group

      - name: customer_country
        type: categorical
        expr: country

      - name: customer_lifetime_days
        type: categorical
        expr: TIMESTAMP_DIFF(CURRENT_TIMESTAMP(), created_at, DAY)

    measures:
      - name: nb_customers
        agg: count_distinct
        expr: user_id

  # ========================================
  # 3. Boxes (exemple hypothétique)
  # ========================================
  - name: boxes_semantic
    model: ref('boxes')
    entities:
      - name: box_id         # ⚠️ Nom de l'entité (pour matcher avec box_sales)
        type: primary
        expr: id             # ⚠️ Colonne réelle DANS la table boxes !

    dimensions:
      - name: box_name
        type: categorical
        expr: name

      - name: box_date
        type: time
        type_params:
          time_granularity: month
        expr: date

    measures:
      - name: nb_boxes
        agg: count_distinct
        expr: id

  # ========================================
  # 4. Orders (exemple hypothétique)
  # ========================================
  - name: orders_semantic
    model: ref('orders')
    entities:
      - name: order_id       # ⚠️ Nom de l'entité (pour matcher avec box_sales)
        type: primary
        expr: id             # ⚠️ Colonne réelle DANS la table orders !

      - name: user_id
        type: foreign
        expr: user_id        # ✅ Dans orders, la colonne s'appelle user_id

    dimensions:
      - name: order_status
        type: categorical
        expr: status

      - name: order_created_at
        type: time
        type_params:
          time_granularity: day
        expr: created_at

    measures:
      - name: nb_orders
        agg: count_distinct
        expr: id

# ========================================
# ⚠️ IMPORTANT : name vs expr
# ========================================

# RÈGLE : expr = nom de la colonne DANS LA TABLE
# RÈGLE : name = nom de l'entité (pour les jointures)

# EXEMPLE CONCRET :

# Dans la table ORDERS :
# - La colonne s'appelle "id"
# - Mais on nomme l'entité "order_id" (pour matcher avec les autres tables)

# Dans la table BOX_SALES :
# - La colonne s'appelle "order_id" (résultat du JOIN)
# - On nomme l'entité "order_id" (pareil)

# JOINTURE AUTOMATIQUE :
# box_sales.order_id (colonne) ←→ orders.id (colonne)
#     ↓ via entité "order_id" ↓

# Table          | Entity name | expr (colonne réelle)
# ---------------|-------------|---------------------
# box_sales      | order_id    | order_id   ← SELECT o.id AS order_id
# orders         | order_id    | id         ← Clé primaire de orders
# boxes          | box_id      | id         ← Clé primaire de boxes
# box_sales      | box_id      | box_id     ← SELECT b.id AS box_id

# ========================================
# COMMENT ÇA MARCHE ?
# ========================================

# Quand vous faites cette requête :
# dbt sl query --metrics total_revenue,nb_customers --group-by customer_age_group

# dbt va :
# 1. Voir que total_revenue vient de box_sales_semantic
# 2. Voir que nb_customers vient de customers_semantic
# 3. Voir que customer_age_group vient de customers_semantic
# 4. Identifier que les deux ont l'entité user_key (ou user_id)
# 5. Créer automatiquement cette jointure :

# SELECT
#   c.age_group as customer_age_group,
#   SUM(bs.net_revenue) as total_revenue,
#   COUNT(DISTINCT c.user_key) as nb_customers
# FROM box_sales bs
# LEFT JOIN customers c ON bs.user_key = c.user_key  -- ✨ JOINTURE AUTO avec user_key !
# GROUP BY c.age_group

# ========================================
# POURQUOI user_key AU LIEU DE user_id ?
# ========================================

# ✅ AVANTAGES de user_key (format: FR_12345) :
# - Clé UNIQUE même en multi-pays (user_id seul peut se dupliquer entre pays)
# - Jointure SÛRE entre box_sales (multi-pays) et customers (multi-pays)
# - Évite les bugs de duplication de données

# ⚠️ PROBLÈME de user_id seul :
# - user_id=123 peut exister en FR ET en DE (2 personnes différentes !)
# - Jointure sur user_id seul → duplication des lignes
# - Il faut TOUJOURS combiner avec dw_country_code

# EXEMPLE PROBLÉMATIQUE :
# SELECT * FROM box_sales bs
# JOIN customers c ON bs.user_id = c.user_id  -- ❌ DANGER !
# → User FR_123 va matcher avec User DE_123 → DOUBLONS !

# SOLUTION :
# SELECT * FROM box_sales bs
# JOIN customers c ON bs.user_key = c.user_key  -- ✅ SAFE !
# → Jointure précise par pays

# ========================================
# JOINTURE MULTI-TABLES
# ========================================

# Requête avec 3 tables :
# dbt sl query --metrics total_revenue,nb_customers,nb_boxes --group-by box_name,customer_country

# dbt va créer :
# SELECT
#   b.name as box_name,
#   c.country as customer_country,
#   SUM(bs.net_revenue) as total_revenue,
#   COUNT(DISTINCT c.user_id) as nb_customers,
#   COUNT(DISTINCT b.id) as nb_boxes
# FROM box_sales bs
# LEFT JOIN customers c ON bs.user_id = c.user_id      -- ✨ user_id
# LEFT JOIN boxes b ON bs.box_id = b.id                -- ✨ box_id
# GROUP BY b.name, c.country
